#!/usr/bin/env python3
"""
Generic ISO G-Code Post-Processor
Compatible with most standard CNC lathes that support ISO G-code
"""

class GenericISOPostProcessor(PostProcessor):
    """Generic post-processor for ISO standard G-code"""

    def __init__(self, machine_config):
        super().__init__(machine_config)
        self.current_tool = None
        self.current_x = None
        self.current_z = None
        self.feed_mode = "MM"  # MM for per minute, REV for per revolution

    def initialize(self):
        """Setup machine-specific headers and initialization"""
        self.add_line("(GENERIC ISO G-CODE)")
        self.add_line("(GENERATED BY TURNLAB)")
        self.add_line("")

        # Standard setup commands
        self.add_line("G18 (XZ PLANE)")

        # Use metric by default, but can be overridden
        if hasattr(self.machine_config, 'units') and self.machine_config['units'] == 'inch':
            self.add_line("G20 (INCH)")
        else:
            self.add_line("G21 (METRIC)")

        self.add_line("G40 (CANCEL CUTTER RADIUS COMPENSATION)")
        self.add_line("G49 (CANCEL TOOL LENGTH COMPENSATION)")
        self.add_line("G80 (CANCEL CANNED CYCLES)")
        self.add_line("G90 (ABSOLUTE POSITIONING)")
        self.add_line("G94 (FEED PER MINUTE)")
        self.add_line("")

    def rapid_move(self, x, z):
        """Generate rapid traverse G-code commands"""
        # Only output coordinates that change
        coords = []
        if x != self.current_x:
            coords.append(f"X{x:.4f}")
            self.current_x = x
        if z != self.current_z:
            coords.append(f"Z{z:.4f}")
            self.current_z = z

        if coords:
            self.add_line(f"G00 {' '.join(coords)}")

    def linear_move(self, x, z, feedrate):
        """Generate linear interpolation with specified feed rate"""
        coords = []
        if x != self.current_x:
            coords.append(f"X{x:.4f}")
            self.current_x = x
        if z != self.current_z:
            coords.append(f"Z{z:.4f}")
            self.current_z = z

        if coords:
            self.add_line(f"G01 {' '.join(coords)} F{feedrate:.3f}")

    def spindle_on(self, rpm, direction=1):
        """Start spindle with speed and rotation direction"""
        # Clamp RPM to machine limits
        max_rpm = self.machine_config.get('max_spindle_speed', 4000)
        rpm = min(rpm, max_rpm)

        if direction >= 0:
            self.add_line(f"M03 S{int(rpm)}")
        else:
            self.add_line(f"M04 S{int(rpm)}")

    def spindle_off(self):
        """Stop spindle operation"""
        self.add_line("M05")

    def coolant_on(self):
        """Coolant system control - on"""
        self.add_line("M08")

    def coolant_off(self):
        """Coolant system control - off"""
        self.add_line("M09")

    def tool_change(self, tool_number):
        """Tool change sequence generation"""
        if self.current_tool != tool_number:
            self.add_line("")
            self.comment(f"TOOL CHANGE TO T{tool_number}")

            # Safe retract before tool change
            if self.current_x is not None and self.current_z is not None:
                safe_z = max(self.current_z, 2.0)  # Safe Z position
                self.rapid_move(self.current_x, safe_z)

            # Tool change
            self.add_line(f"T{tool_number}")
            self.current_tool = tool_number

    def finalize(self):
        """Program end, return to home position, cleanup operations"""
        self.add_line("")
        self.comment("PROGRAM END")

        # Safe retract
        if self.current_x is not None and self.current_z is not None:
            self.rapid_move(self.current_x + 5.0, self.current_z + 10.0)

        self.add_line("M30 (PROGRAM END)")

    def dwell(self, seconds):
        """Generate dwell/pause commands"""
        self.add_line(f"G04 P{seconds:.2f}")
        return True

    def comment(self, text):
        """Add comments to G-code output"""
        # Use semicolon for comments (more universal than parentheses)
        self.add_line(f"; {text}")
        return True